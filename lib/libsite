# vim: tw=0:ts=4:sw=4:et:ft=bash

#. Site Engine -={
#. 1.1  Paths -={
: ${PROFILE?}
export SITE=${HOME}/.site
export SITE_ETC=${SITE}/profile/${PROFILE?}/etc
export SITE_MOD=${SITE}/profile/${PROFILE?}/module
export SITE_MOD_CORE=${SITE}/module
export SITE_LIB=${SITE}/profile/${PROFILE?}/lib
export SITE_LIB_CORE=${SITE}/lib
export SITE_SCM=$(dirname $(dirname $(readlink ~/bin/site)))
export SITE_UNITDATA=${SITE}/share/unittest.csv
export SITE_EXTERN=${SITE}/extern
export SITE_EXTERN_LIBSH=${SITE_EXTERN}/lib/libsh
export SITE_EXTERN_LIBPY=${SITE_EXTERN}/lib/libpy
export SITE_EXTERN_LIBRB=${SITE_EXTERN}/lib/librb

export SITE_LIBEXEC=${SITE}/profile/${PROFILE?}/libexec
export SITE_LIBEXEC_CORE=${SITE}/libexec
export SITE_LIBEXEC_EXTERN=:${SITE_EXTERN}/libexec

export PATH=${PATH}:${SITE_LIBEXEC}:${SITE_LIBEXEC_CORE}:${SITE_LIBEXEC_EXTERN}
#. }=-
#. 1.2  Core Configuration -={
unset  CDPATH
export BASENAME=$(basename $0)
source ${SITE_MOD_CORE?}/cpf
[ ${#CORE_MODULES[@]} -gt 0 ] || : ${CORE_MODULES?}
#. }=-
#. 1.3  Date/Time -={
export NOW=$(date --utc +%s)
#. FIXME: Mac OS X needs this instead:
#. FIXME: export NOW=$(date -u +%s)
#. }=-
#. 1.4  User/Profile Configuration -={
declare -A USER_MODULES
if [ -d ${SITE_ETC} ]; then
    unset USER_MODULES
    source ${SITE_ETC}/site.conf
#    [ ${#USER_MODULES[@]} -gt 0 ] || : ${USER_MODULES?}
#    #. TODO: Move this to ldap module
    : ${USER_TLDS[@]?}
    : ${USER_TLD_DEFAULT?}
#    : ${USER_UDN?}
#    : ${USER_GDN?}
#    : ${USER_NDN?}
else
    cpf "%{@warn:NOTE}: Your profile %{@profile:${PROFILE}} has not been initialized.\n"
fi
#. }=-
#. 1.5  ShUnit2 -={
export SHUNIT2=$(which shunit2)
#. }=-
#. 1.6  ShFlags -={
export SHFLAGS=${SITE_EXTERN_LIBSH}/shflags
source ${SHFLAGS?}
#. }=-
#. 1.7  Error Code Constants -={
true
TRUE=$?
CODE_SUCCESS=${TRUE?}

false
FALSE=$?
CODE_FAILURE=${FALSE?}

CODE_ERROR=1               #. 1..63   Errors
CODE_E01=1
CODE_E02=2
CODE_E03=3
CODE_E04=4
CODE_E05=5
CODE_E06=6
CODE_E07=7
CODE_E08=8
CODE_E09=9

CODE_USER_MAX=63           #. 64..127 Internal
CODE_DISABLED=64
CODE_USAGE_SHORT=90
CODE_USAGE_MODS=91
CODE_USAGE_MOD=92
CODE_USAGE_FN_GUESS=93
CODE_USAGE_FN_SHORT=94
CODE_USAGE_FN_LONG=95

export SITE_DELIM=$(printf "\x07")

CODE_DEFAULT=${CODE_USAGE_FN_LONG?}
#. }=-
#. 1.8  Modules -={
declare -A SITE_IMPORTED
function core:softimport() {
    local -i e=9

    if [ $# -eq 1 ]; then
        local module=$1
        if [ -z "${SITE_IMPORTED[${module}]}" ]; then
            e=2 #. No such module
            if [ ${USER_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_MOD}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_MOD}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_MOD_CORE}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_MOD_CORE}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 0 -o ${USER_MODULES[${module}]-9} -eq 0 ]; then
                e=${CODE_FAILURE} #. Disabled
            fi
            SITE_IMPORTED[${module}]=$e
        else
            e=${SITE_IMPORTED[${module}]}
        fi
    fi

    return $e
}

function core:docstring() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        local module=$1

        e=2 #. No such module
        if [ ${USER_MODULES[${module}]-9} -eq 1 ]; then
            if [ -f ${SITE_MOD}/${module} ]; then
                sed -ne '/^:<<\['${FUNCNAME}'\]/,/\['${FUNCNAME}'\]/{n;p;q}' ${SITE_MOD}/${module}
                e=$?
            fi
        elif [ ${CORE_MODULES[${module}]-9} -eq 1 ]; then
            if [ -f ${SITE_MOD_CORE}/${module} ]; then
                sed -ne '/^:<<\['${FUNCNAME}'\]/,/\['${FUNCNAME}'\]/{n;p;q}' ${SITE_MOD_CORE}/${module}
                e=$?
            fi
        elif [ ${CORE_MODULES[${module}]-9} -eq 0 -o ${USER_MODULES[${module}]-9} -eq 0 ]; then
            e=${CODE_FAILURE} #. Disabled
        fi
        SITE_IMPORTED[${module}]=$e
    fi

    return $e
}

function core:import() {
    core:softimport $@
    local -i e=$?
    [ $e -eq 0 ] || core:raise EXCEPTION_BAD_MODULE

    return $e
}

function :core:requires() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        e=${CODE_SUCCESS}

        if echo "${1}"|grep -q '/'; then
            [ -e "${1}" ] || e=2
        elif ! which "${1}" > /dev/null 2>&1; then
            e=${CODE_FAILURE}
        fi
    fi

    return $e
}

function core:requires() {
    #. Usage examples:
    #.
    #.     core:requires awk
    #.     core:requires PERL LWP::Protocol::https
    local -i e=${CODE_SUCCESS}

    local required;
    case $#:${1} in
        1:*)
            if ! :core:requires $1; then
                local caller="${FUNCNAME[1]}"
                #. TODO: Check if ${caller} is a valid/plausible executable name
                local caller_is_mod=$(( ${USER_MODULES[${caller/:*/}]-0} + ${CORE_MODULES[${caller/:*/}]-0} ))
                if [ ${caller_is_mod} -ne 0 ]; then
                    core:raise EXCEPTION_MISSING_EXEC $1
                fi
            fi
        ;;
        *:PERL)
            for required in ${@:2}; do
                if ! perl -M${required} -e ';' 2>/dev/null; then
                    core:raise EXCEPTION_MISSING_PERL_MOD ${required}
                fi
            done
        ;;
        *:PYTHON)
            for required in ${@:2}; do
                if ! python -c "import ${required}" 2>/dev/null; then
                    core:raise EXCEPTION_MISSING_PYTHON_MOD ${required}
                fi
            done
        ;;
        *:ALL)
            e=${CODE_SUCCESS}
            for required in ${@:2}; do
                if ! :core:requires "${required}"; then
                    e=${CODE_FAILURE}
                    core:raise EXCEPTION_MISSING_EXEC ${required}
                    break
                fi
            done
        ;;
        *:ANY)
            e=${CODE_FAILURE}
            for required in ${@:2}; do
                if :core:requires "${required}"; then
                    e=${CODE_SUCCESS}
                    break
                fi
            done
            if [ $e -ne ${CODE_SUCCESS} ]; then
                core:raise EXCEPTION_MISSING_EXEC "${@:2}"
            fi
        ;;
        *) core:raise EXCEPTION_BAD_FN_CALL $*;;
    esac

    test $e -eq 0 && return $e || exit $e
}
#. }=-
#. 1.9  Caching -={
#. 0 means cache forever (default)
#. >0 indeicates TTL in seconds
declare -g g_CACHE_TTL=0

SITE_CACHE=${HOME}/.cache/${BASENAME?}
mkdir -p ${SITE_CACHE?}
chmod 3770 ${SITE_CACHE?} 2>/dev/null

#. Keep track if cache was used globally
declare g_CACHE_USED=${SITE_CACHE}/.cache_used
rm -f ${g_CACHE_USED}

CACHE_OUT='eval :core:cached "$*" && return ${CODE_SUCCESS}'
CACHE_IN='eval :core:cache "$*"'
CACHE_EXIT='eval return ${PIPESTATUS[0]}'
:<<! USAGE:
Any function (private or internal only, do not try and cache-enable public
functions!) can be cache-enabled simply by insertin two lines; one right at
the start of the function, and one right at the end:

function <module>:<function>() {
  #. vvv 1. Use cache and return or continue
  ${CACHE_OUT}; {

    ...

  } | ${CACHE_IN}; ${CACHE_EXIT}
  #. ^^^ 2. Update cache if previous did not return
}
function :<module>:<function>() { #. Same as above...; }
function ::<module>:<function>() { #. Same as above...; }

Also take note of the indenting of 2 spaces, this makes it non-obstructive, so
you can maintain the usual 4-space indents, and insert these in and out as
you please.

Note that public functions that take local shflags will not allow caching,
and will generate an error.

Finally, the default cache time is g_CACHE_TTL minutes, but this can be
modified for each function by creating the auxiliary function:

function :[:]<module>:<function>:cached() { echo 3600; }

The value echoed will be the replacement TTL.

Don't use this all over the place, only on computationally expensive code
or otherwise slow code (network latency) that is expected to also produce the
same result almost alll the time, for example dns might be a good candidate,
whereas remote code execution is probably a bad candidate.
!

function :core:age() {
    local -i e=${CODE_FAILURE}

    local filename="$1"
    if [ -e ${filename} ]; then
        local -i changed=$(stat -c %Y "${filename}")
        local -i now=$(date +%s)
        local -i elapsed
        let elapsed=now-changed
        echo ${elapsed}
        e=${CODE_SUCCESS}
    fi

    return ${e}
}

function :core:cache:file() {
    local -i e=${CODE_FAILURE}

    local modfn="$1"
    local cachefile
    if [ "$(type -t ${modfn}:cachefile)" == "function" ]; then
        #. File-Cached...
        shift 1
        cachefile=$(${modfn}:cachefile $*)
    else
        #. Output-Cached...
        test -d ${SITE_CACHE}/cache || mkdir ${SITE_CACHE}/cache

        local effective_format=${g_FORMAT}
        if [[ $1 =~ ^: ]] && [ ${g_FORMAT} == "ansi" ]; then
            effective_format=text
        fi

        cachefile=${SITE_CACHE}/cache/${1//:/=}
        cachefile+=+${g_TLDID}
        cachefile+=+${g_VERBOSE}
        cachefile+=+$(echo -ne "${2}"|md5sum|awk '{print$1}')
        cachefile+=.${effective_format}
    fi

    echo "${cachefile}"

    e=${CODE_SUCCESS}
    return $e
}

function :core:cache:age() {
    local -i e=${CODE_FAILURE}

    local cachefile=$(:core:cache:file $*)

    :core:age "${cachefile}"
    e=$?

    return $e
}

function ::core:cache:cachetype() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        local cachefile=$1
        local cachetype=file

        if [ "${cachefile:0:1}" == '/' ]; then
            outputcached="${SITE_CACHE}/cache"
            if [ "${cachefile//${outputcached}/}" != "${cachefile}" ]; then
                cachetype=output
            fi
            e=${CODE_SUCCESS}
        else
            core:raise EXCEPTION_SHOULD_NOT_GET_HERE
        fi
    fi

    echo "${cachetype}"
    return $e
}

function :core:cache() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        local modfn=${FUNCNAME[1]}
        local argv="$1"
        local cachefile=$(:core:cache:file "${modfn}" "${argv}")

        #. If it's a output-cached file..
        case $(::core:cache:cachetype ${cachefile}) in
            output)
                :> ${cachefile}
                chmod 600 ${cachefile}
                while read line; do
                    echo "$line" >> ${cachefile}
                done

                cat ${cachefile}
            ;;
            file)
                : PASS
            ;;
        esac

        local -i e=${CODE_SUCCESS}
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function :core:cached() {
    #. TTL of 0 means cache forever
    #. TTL > 0 means to cache for TTL seconds
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        if [ ${g_CACHED} -eq 1 ]; then
            local modfn=${FUNCNAME[1]}
            if [ "$(type -t ${modfn}:shflags)" != "function" ]; then
                local -i ttl=0
                [ "$(type -t ${modfn}:cache)" == "function" ] &&
                    ttl=$(${modfn}:cache) ||
                        ttl=${g_CACHE_TTL}

                local argv="$1"
                local cachefile=$(:core:cache:file "${modfn}" "${argv}")
                local -i age
                age=$(:core:age ${cachefile})
                if [ $? -eq ${CODE_SUCCESS} ]; then
                    if [ ${ttl} -gt 0 -a ${age} -ge ${ttl} ]; then
                        rm -f ${cachefile}
                    else
                        case $(::core:cache:cachetype ${cachefile}) in
                            output)
                                cat ${cachefile}
                                echo ${cachefile} >> ${g_CACHE_USED}
                                e=${CODE_SUCCESS}
                            ;;
                            file)
                                e=${CODE_SUCCESS}
                            ;;
                        esac
                    fi
                fi
            else
                theme ERR "Caching functions that take local shflags not supported." >&2
            fi
        fi
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}
#. }=-
#. 1.10 Deadman -={
export SITE_DEADMAN=${SITE_CACHE}/deadman
#. }=-
#. 1.11 Execution -={
: ${SITE_USERNAME:=$(whoami)}

function ::core:execute:internal() {
    local module=$1
    local fn=$2
    shift 2
    #set -x
    :${module}:${fn} ${*}
    #set +x
    return $?
}

function ::core:execute:private() {
    local module=$1
    local fn=$2
    shift 2
    #set -x
    ::${module}:${fn} ${*}
    #set +x
    return $?
}

#. GLOBAL_OPTS 1/4:
declare -i g_HELP=0
declare -i g_VERBOSE=0
declare -i g_LDAPHOST=-1
declare -i g_CACHED=0
declare g_FORMAT=ansi
declare g_TLDID='m' #XXX
declare g_DUMP

function ::core:shflags() {
    local -i e=${CODE_FAILURE}

    #. Extract the first 2 non-flag tokens as module and function
    #. All remaining tokens are addred to the new argv array
    local -a argv
    local -i argc=0
    local module=-
    local fn=-

    local arg
    for arg in $@; do
        if [ ${arg:0:1} != '-' ]; then
            if [ "${module}" == "-" ]; then
                module="${arg?}"
            elif [ "${fn}" == "-" ]; then
                fn="${arg?}"
            else
                argv[${argc}]="${arg?}"
                ((argc++))
            fi
        else
            argv[${argc}]="${arg}"
            ((argc++))
        fi
    done
    set -- ${argv[@]}

    #. GLOBAL_OPTS 2/4: Our generic and global optiones
    DEFINE_boolean help     false            "<help>"                   H
    DEFINE_boolean verbose  false            "<verbose>"                V
    DEFINE_boolean cached   false            "<use-cache>"              C
    DEFINE_string  format   "${g_FORMAT}"    "ansi|text|csv|html|email" F
    DEFINE_integer ldaphost "${g_LDAPHOST}"  "<ldap-host-index>"        L
    DEFINE_string  tldid    "${g_TLDID}"     "<top-level-domain-id>"    T

    #. Out module/function-specific options
    local -a extra
    if [ ${#module} -gt 0 ]; then
        core:softimport ${module}
        if [ $? -eq 0 ]; then
            if [ "$(type -t ${module}:${fn}:shflags)" == "function" ]; then
                #. shflags function defined, so let's use it...
                while read f_type f_long f_default f_desc f_short; do
                    DEFINE_${f_type} "${f_long}" "${f_default}" "${f_desc}" "${f_short}"
                    extra+=( FLAGS_${f_long} )
                done < <( ${module}:${fn}:shflags )
            fi
        fi
        cat <<!
declare -g module=${module:-}
declare -g fn=${fn:-}
!
    fi

    #. Process it all
    FLAGS "$@" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        #. GLOBAL_OPTS 3/4:
        FLAGS_HELP="site ${module} ${fn} [<flags>]"
        #. Booleans get inverted:
        g_HELP=!${FLAGS_help?}; unset FLAGS_help
        g_VERBOSE=!${FLAGS_verbose?}; unset FLAGS_verbose
        g_CACHED=!${FLAGS_cached?}; unset FLAGS_cached
        #. Everything else is straight-forward:
        g_FORMAT=${FLAGS_format?}; unset FLAGS_format
        g_LDAPHOST=${FLAGS_ldaphost?}; unset FLAGS_ldaphost
        g_TLDID=${FLAGS_tldid?}; unset FLAGS_tldid

        if [ ${#g_TLDID} -eq 0 ] || [ ${#USER_IFACE[${g_TLDID}]} -gt 0 ]; then
            cat <<!
#. GLOBAL_OPTS 4/4:
declare g_HELP=${g_HELP?}
declare g_VERBOSE=${g_VERBOSE?}
declare g_FORMAT=${g_FORMAT?}
declare g_LDAPHOST=${g_LDAPHOST?}
declare g_TLDID=${g_TLDID?}
declare g_CACHED=${g_CACHED?}
set -- ${FLAGS_ARGV?}
!
            e=${CODE_SUCCESS}
        fi
    else
        cat <<!
g_DUMP="$(FLAGS "$@" 2>&1|sed -e '1,2 d' -e 's/^/    /')"
!
    fi

    if [ $e -eq ${CODE_SUCCESS} ]; then
        cat <<!
$(for key in ${extra[@]}; do echo ${key}=${!key}; done)
!
    fi

    return $e
}

function :core:execute() {
    local -i e=${CODE_USAGE_MODS}

    if [ $# -ge 1 ]; then
        e=${CODE_USAGE_MOD}

        if [ $# -ge 2 ]; then
            declare -g module=$1
            declare -g fn=$2
            shift 2

            if [ "$(type -t ${module}:${fn})" == "function" ]; then
                case ${g_FORMAT} in
                    dot|text|png)    SITE_IN_COLOR=0 ${module}:${fn} ${*};;
                    html|email)      SITE_IN_COLOR=1 ${module}:${fn} ${*};;
                    ansi)
                        if [ -t 1 ]; then
                            SITE_IN_COLOR=1 ${module}:${fn} ${*}
                        else
                            SITE_IN_COLOR=0 ${module}:${fn} ${*}
                        fi
                    ;;
                    *) core:raise EXCEPTION_SHOULD_NOT_GET_HERE "Format checks should have already taken place!";;
                esac
                e=$?

                if [ ${SITE_IN_COLOR} -eq 1 ]; then
                    if [ "$(type -t ${module}:${fn}:alert)" == "function" ]; then
                        cpf "%{r:ALERTS}%{bl:@}%{g:${PROFILE}} %{!function:${module} ${fn}}:\n"
                        while read line; do
                            set ${line}
                            local alert=$1
                            shift
                            theme ${alert} "$*"
                        done < <(${module}:${fn}:alert)
                        cpf
                    fi

                    if [ -f ${g_CACHE_USED} -a ${g_VERBOSE} -eq 1 ]; then
                        cpf
                        local age
                        local cachefile
                        cpf "%{@comment:#. Cached Data} %{r:%s}\n" "-=["
                        while read cachefile; do
                            age=$(:core:age "${cachefile}")

                            case $(::core:cache:cachetype ${cachefile}) in
                                output)
                                    cpf "    %{b:%s} is %{@int:%ss} old..." "$(basename ${cachefile})" "${age}"
                                ;;
                                file)
                                    cpf "    %{@path:%s} is %{@int:%ss} old..." "${cachefile}" "${age}"
                                ;;
                            esac
                            theme WARN "CACHED"
                        done < ${g_CACHE_USED}
                        cpf "%{@comment:#.} %{r:%s}\n" "]=-"
                    fi
                fi
            else
                theme ERR_INTERNAL "Function ${module}:${fn} not defined!"
            fi
        fi
    fi

    if [ ${SITE_IN_COLOR} -eq 1 -a $e -eq 0 -a ${SECONDS} -ge 30 ]; then
        theme INFO "Execution time was ${SECONDS} seconds"
    fi

    return $e
}

function :core:git() {
    local root=$(dirname $(readlink ~/.site/etc))
    cd ${root}
    git "$@"
    return $?
}

function ::core:eval:dereference() {
    #. NOTE: you myst eval the output of this function!
    #. take $1, and make it equal to ${$1}
    #.
    #. If the variable starts with _, remove it in the new variable
    #. Input: _my_var=something; something=( A B C )
    #. Output: my_var=( A B C )
    if [ ! -t 1 ]; then
        echo "unset ${1} && eval \$(declare -p ${!1}|sed -e 's/declare -\([a-qs-zA-Z]*\)r*\([a-qs-zA-Z]*\) ${!1}=\(.*\)/declare -\1\2 ${1}=\3/')";
    else
        core:raise EXCEPTION_BAD_FN_CALL \
            "This function must be called in a subshell, and evaled afterwards!"
    fi
}

function :core:functions() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 2 ]; then
        local fn_type=$1
        local module=$2
        case ${fn_type} in
            public)
                declare -F |
                    awk -F'[ ]' '$3~/^'${module}':/{print$3}' |
                    awk -F ':+' '{print$2}' |
                    sort -u
                e=${CODE_SUCCESS}
            ;;
            private)
                declare -F |
                    awk -F'[ ]' '$3~/^:'${module}':/{print$3}' |
                    awk -F ':+' '{print$3}' |
                    sort -u
                e=${CODE_SUCCESS}
            ;;
            internal)
                declare -F |
                    awk -F'[ ]' '$3~/^::'${module}':/{print$3}' |
                    awk -F ':+' '{print$3}' |
                    sort -u
                e=${CODE_SUCCESS}
            ;;
            *) core:raise EXCEPTION_BAD_FN_CALL;;
        esac
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function :core:usage() {
    local module=$1
    local fn=$2
    local mode=${3---short}
    [ $# -eq 2 ] && mode=${3---long}

    if [ ${#FUNCNAME[@]} -lt 4 ]; then
        cpf "%{+bo}%{bl:site}%{-bo} %{@version:%s}, %{wh:the system-administration bash scripting suite}\n" $(:core:git describe "--always")
        cpf "Using %{@path:%s} %{@version:%s}" "${BASH}" "${BASH_VERSION}"
        if [ ${#SITE_SHELL} -eq 0 ]; then
            cpf " %{@comment:(export SITE_SHELL to override)}"
        else
            cpf " %{r:(SITE_SHELL override active)}"
        fi
        printf "\n\n"
    fi

    if [ $# -eq 0 ]; then
        #. Usage for site
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}}\n"
        for profile in USER_MODULES CORE_MODULES; do
            eval $(::core:eval:dereference profile) #. Will create ${profile} array
            for module in ${!profile[@]}; do (
                core:import ${module}
                local -a fn_public=( $(:core:functions public ${module}) )
                local -a fn_private=( $(:core:functions private ${module}) )
                if [ ${#fn_public[@]} -gt 0 ]; then
                    local docstring=$(core:docstring ${module})
                    cpf "    %{bl:${BASENAME}} %{!module:${module}}:%{@int:%s}/%{@int:%s}%{@comment:%s}\n"\
                        "${#fn_public[@]}" "${#fn_private[@]}" "${docstring:+; ${docstring}}"
                else
                    cpf "!   %{bl:${BASENAME}} %{!module:${module}}:%{@int:%s}/%{@int:%s}%{@comment:%s}\n"\
                        "${#fn_public[@]}" "${#fn_private[@]}" "${docstring:+; ${docstring}}"
                fi
            ); done
        done
    elif [ $# -eq 1 ]; then
        core:import ${module}
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}} %{!module:${module}}\n"
        local -a fns=( $(:core:functions public ${module}) )
        for fn in ${fns[@]}; do
            local usage_fn="${module}:${fn}:usage"
            local usagestr="{no-args}"
            if [ "$(type -t ${usage_fn})" == "function" ]; then
                usagestr="$(${usage_fn})"
                cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} %{c:%s}\n" "${usagestr}"
            else
                cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} %{bl:%s}\n" "${usagestr}"
            fi
        done

        if [ ${g_VERBOSE?} -eq 1 -a ${#FUNCNAME[@]} -lt 4 ]; then
            cpf "\n%{!module:${module}} %{g:changelog}\n"
            local modfile=${SITE_MOD}/${module}
            [ -f ${modfile} ] || modfile=${SITE_MOD_CORE}/${module}
            cd ${SITE_SCM}
            :core:git --no-pager\
                log --follow --all --format=format:'    |___%C(bold blue)%h%C(reset) %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)â€” %an%C(reset)%C(bold yellow)%d%C(reset)'\
                --abbrev-commit --date=relative -- "${modfile}"
            cd ${OLDPWD}
            echo
        fi
        echo
    elif [ $# -ge 2 ]; then
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}} %{!function:${module}:${fn}}\n"
        cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} "

        local usage_s=${module}:${fn}:usage
        if [ "$(type -t $usage_s)" == "function" ]; then
            cpf "%{c:%s}\n" "$(${usage_s})"
        else
            cpf "%{bl:%s}\n" "{no-args}"
        fi

        case ${mode} in
            --short) : pass ;;
            --long)
                local usage_l=${module}:${fn}:help
                local -i i=0
                if [ "$(type -t $usage_l)" == "function" ]; then
                    cpf
                    local indent=""
                    while read line; do
                        cpf "%{c:%s}\n" "${indent}${line}"
                        [ $i -eq 0 ] && indent+="    "
                        ((i++))
                    done <<< "`${usage_l}`"
                fi

                if [ ${#g_DUMP} -gt 0 ]; then
                    cpf
                    cpf "%{c:%s}\n" "Flags:"
                    echo "${g_DUMP}"
                fi
            ;;
        esac
    fi
}

function :core:complete() {
    local module=$1
    local fn=$2
    for afn in $(declare -F|awk -F'[ :]' '$3~/^'${module}'$/{print$4}'|sort -n); do
        local AC_${module}_${afn}
    done
    local -a completed=( $(eval echo \${!AC_${module}_${fn}*}) )
    if echo ${completed[@]} | grep -qE "\<AC_${module}_${fn}\>"; then
        echo ${fn}
    else
        echo ${completed[@]//AC_${module}_/}
    fi
}

function core:wrapper() {
    if [ -e ${SITE_DEADMAN?} ]; then
        theme HAS_FAILED "CRITICAL ERROR; ABORTING!" >&2
        exit 1
    fi

    local -i e=${CODE_USAGE_MODS}

    local setdata
    local -i e_shflags
    setdata="$(::core:shflags $*)"
    e_shflags=$?
    eval "${setdata}"

    local regex=':+[a-z0-9]+(:[a-z0-9]+) |*'
    core:softimport "${module?}"
    case $?/${module?}/${fn?} in
        0/-/-)                                                                                   e=${CODE_USAGE_MODS} ;;
        0/*/-)    :core:execute          ${module}            2>&1 | grep --color -E "${regex}"; e=${PIPESTATUS[0]}   ;;
        0/*/::*) ::core:execute:private  ${module} ${fn:2} $* 2>&1 | grep --color -E "${regex}"; e=${PIPESTATUS[0]}   ;;
        0/*/:*)  ::core:execute:internal ${module} ${fn:1} $* 2>&1 | grep --color -E "${regex}"; e=${PIPESTATUS[0]}   ;;
        0/*/*)
            local -a completed=( $(:core:complete ${module} ${fn}) )

            local -A supported_formats=( [html]=1 [email]=1 [ansi]=1 [text]=1 [dot]=0 )
            if [ "$(type -t ${module}:${fn}:formats)" == "function" ]; then
                for format in $( ${module}:${fn}:formats ); do
                    supported_formats[${format}]=2
                done
            fi

            if [ ${#completed[@]} -eq 1 ]; then
                fn=${completed}
                if [ ${e_shflags} -eq ${CODE_SUCCESS} ]; then
                    if [ ${g_FORMAT?} == "email" ]; then
                        :core:execute ${module} ${completed} $* 2>&1 |
                            grep --color -E "${regex}" |
                            ${SITE_LIBEXEC_CORE}/ansi2html |
                            mail -a "Content-type: text/html" -s "Site Report [${module} ${completed} $*]" ${SITE_EMAIL}
                            e=${PIPESTATUS[3]}
                    elif [ ${g_FORMAT?} == "html" ]; then
                        :core:execute ${module} ${completed} $* 2>&1 |
                            grep --color -E "${regex}" |
                            ${SITE_LIBEXEC_CORE}/ansi2html
                            e=${PIPESTATUS[2]}
                    elif [ -z "${supported_formats[${g_FORMAT}]}" ]; then
                        theme ERR_USAGE "That is not a supported format."
                        e=${CORE_FAILURE}
                    elif [ ${supported_formats[${g_FORMAT}]} -gt 0 ]; then
                        :core:execute ${module} ${completed} $*
                        e=$?
                    else
                        theme ERR_USAGE "This function does not support that format."
                        e=${CORE_FAILURE}
                    fi
                else
                    e=${CODE_USAGE_FN_LONG}
                fi
            elif [ ${#completed[@]} -gt 1 ]; then
                theme ERR_USAGE "Did you mean one of the following:"
                for acfn in ${completed[@]}; do
                    echo "    ${BASENAME} ${module} ${acfn}"
                done
                e=${CODE_USAGE_FN_GUESS}
            else
                theme ERR_USAGE "${fn} not defined"
                e=${CODE_USAGE_MOD}
            fi
        ;;
        2/-/-) e=${CODE_USAGE_MODS};;
        2/*/*)
            theme ERR_USAGE "Module ${module} has not been defined"
            e=${CODE_FAILURE}
        ;;
        1/*/*)
            theme ERR_USAGE "Module ${module} has been administratively disabled"
            e=${CODE_DISABLED}
        ;;
        */*/*)
            e=${CODE_FAILURE}
            core:raise EXCEPTION_BAD_FN_CALL "Check call/caller to/of \`core:softimport $*'"
        ;;
    esac

    case $e in
        ${CODE_USAGE_MODS})    :core:usage ;;
        ${CODE_USAGE_SHORT})   :core:usage ${module} ;;
        ${CODE_USAGE_MOD})     :core:usage ${module} ;;
        ${CODE_USAGE_FN_LONG}) :core:usage ${module} ${fn} ;;
        0) : noop;;
    esac

    return $e
}
#. }=-
#. 1.12 Exceptions -={
EXCEPTION=63
EXCEPTION_BAD_FN_CALL=64
EXCEPTION_MISSING_EXEC=65
EXCEPTION_BAD_MODULE=66
EXCEPTION_DEPRECATED=67
EXCEPTION_MISSING_PERL_MOD=68
EXCEPTION_MISSING_PYTHON_MOD=69
EXCEPTION_INVALID_FQDN=80
EXCEPTION_SHOULD_NOT_GET_HERE=125
EXCEPTION_NOT_IMPLEMENTED=126
EXCEPTION_UNHANDLED=127
declare -A RAISE=(
    [${EXCEPTION_BAD_FN_CALL}]="Bad function call internally"
    [${EXCEPTION_MISSING_EXEC}]="Required executable not found"
    [${EXCEPTION_BAD_MODULE}]="Bad module"
    [${EXCEPTION_DEPRECATED}]="Deprecated function call"
    [${EXCEPTION_MISSING_PERL_MOD}]="Required perl module missing"
    [${EXCEPTION_MISSING_PYTHON_MOD}]="Required python module missing"
    [${EXCEPTION_SHOULD_NOT_GET_HERE}]="Process flow should never get here"
)
function core:raise() {
    touch ${SITE_DEADMAN?}

    : !!! CRITICAL FAILURE !!!
    sleep 3
    local -i e=$1

    cpf "%{r}Exception[%{st:%s}]: %s ($*) %{N}\n" ${e} "${RAISE[$e]-[UNKNOWN EXCEPTION:$e]}" 1>&2

    if [ ${#module} -gt 0 ]; then
        if [ ${#fn} -gt 0 ]; then
            cpf "Function %{c:${module}:${fn}()}" 1>&2
            echo "Critical failure in function ${module}:${fn}()" >> ${SITE_DEADMAN?}
        else
            cpf "Module %{c:${module}}" 1>&2
            echo "Critical failure in module ${module}" >> ${SITE_DEADMAN?}
        fi
    else
        cpf "File %{@path:$0}" 1>&2
        echo "Critical failure in file ${0}" >> ${SITE_DEADMAN?}
    fi

    cpf " %{r:failed with exception} %{g:$e}; %{c:traceback}:\n" 1>&2
    local i=0
    local -i frames=${#BASH_LINENO[@]}
    #. ((frames-2)): skips main, the last one in arrays
    for ((i=frames-2; i>=0; i--)); do
        cpf "  File %{g:${BASH_SOURCE[i+1]}}, line %{g:${BASH_LINENO[i]}}, in %{r:${FUNCNAME[i+1]}()}\n" 1>&2
        # Grab the source code of the line
        local code=$(sed -n "${BASH_LINENO[i]}{s/^ *//;p}" "${BASH_SOURCE[i+1]}")
        cpf "    %{wh:>>>} %{c}${code}%{N}\n" 1>&2
    done

    exit $e
}
#. }=-
#. }=-
