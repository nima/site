# vim: tw=0:ts=4:sw=4:et:ft=bash

#. Optional long help message
function util:timeout:help() {
    cat <<EOF

    [-t timeout] [-i interval] [-d delay] command
    Execute a command with a time-out.
    Upon time-out expiration SIGTERM (15) is sent to the process. If SIGTERM
    signal is blocked, then the subsequent SIGKILL (9) terminates it.

    -t timeout
        Number of seconds to wait for command completion.
        Default value: $DEFAULT_TIMEOUT seconds.

    -i interval
        Interval between checks if the process is still alive.
        Positive integer, default value: $DEFAULT_INTERVAL seconds.

    -d delay
        Delay between posting the SIGTERM signal and destroying the
        process by SIGKILL. Default value: $DEFAULT_DELAY seconds.

    Note that Bash does not support floating point arithmetic
    (sleep does), therefore all delay/time values must be integers.
EOF
}

function util:timeout:usage() { echo "[-t|--timeout <timeout>] [-i|--interval <interval>] [-d|--delay <delay>]"; }

function util:timeout:shflags() {
    # Timeout.
    local -i DEFAULT_TIMEOUT=9
    # Interval between checks if the process is still alive.
    local -i DEFAULT_INTERVAL=1
    # Delay between posting the SIGTERM signal and destroying the process by SIGKILL.
    local -i DEFAULT_DELAY=1

    cat <<!
integer timeout ${DEFAULT_TIMEOUT} <timeout> t
integer interval ${DEFAULT_INTERVAL} <interval> i
integer delay ${DEFAULT_DELAY} <delay> d
!
}

function util:timeout() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -ge 1 ]; then
        e=${CODE_FAILURE}
        local -i delay=${FLAGS_delay?}; unset FLAGS_delay
        local -i timeout=${FLAGS_timeout?}; unset FLAGS_timeout
        local -i interval=${FLAGS_interval?}; unset FLAGS_interval
        (
            local -i t
            ((t = timeout))
            while ((t > 0)); do
                sleep ${interval}
                kill -0 $$ || exit 0
                ((t -= interval))
            done

            # Be nice, post SIGTERM first.
            # The 'exit 0' below will be executed if any preceeding command fails.
            kill -s SIGTERM $$ && kill -0 $$ || exit 0
            sleep $delay
            kill -s SIGKILL $$
        ) 2>/dev/null &

        exec "$@"
    fi

    return $e
}

function :util:date:i2s() {
    if [ $# -eq 1 ]; then
        #. Convert seconds to datestamp
        date --utc --date "1970-01-01 $1 sec" "+%Y%m%d%H%M%S"
        #. FIXME: Mac OS X needs this line instead:
        #. FIXME: date -u -j "010112001970.$1" "+%Y%m%d%H%M%S"
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi
}

function :util:date:s2i() {
    if [ $# -eq 1 ]; then
        local YYYY=${1:0:4}
        local mm=${1:4:2}
        local dd=${1:6:2}
        local HH=${1:8:2}
        local MM=${1:10:2}
        local SS=${1:12:2}

        #. Convert datestamp to seconds
        date --utc --date "${YYYY}-${mm}-${dd} ${HH}:${MM}:${SS}" "+%s"
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi
}

function :util:listify() {
    if [ $# -gt 0 ]; then
        #. Method 1
        IFS=, read -a s <<< "$*"
        echo ${s[@]}
        return

        #. Method 2
        IFS=, read -a s <<< $*
        echo ${s}
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi
}

function :util:uniq() {
    if [ $# -gt 0 ]; then
        tr ' ' '\n' <<< "${@}" | sort -u | tr '\n' ' '
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi
}

function :util:dups() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 0 ]; then
        while read line; do
            echo ${line}
        done | sort -n | awk 'BEGIN{last=0};$1~/uidNumber/{if(last==$2){print$2};last=$2}' | sort -u
        e=${CODE_SUCCESS}
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function :util:join() {
    if [ $# -eq 2 ]; then
        #. array=( a b c ); :util:join $delim array
        local IFS=$1
        eval "echo \"\${${2}[*]}\""
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi
}

#function :util:cphash() {
#    local assoc_array_string=$(local -p $2)
#    eval "local -A $1=${assoc_array_string#*=}"
#    echo eval $(local -p $1)
#}
#
#function :util:locald() {
#    local -pA|awk 'BEGIN{e='${CODE_FAILURE}'};$0~/local .*'$1'=/{e='${CODE_SUCCESS}'};END{exit(e)}'
#    return $?
#}

#. Set Operations -={
#function :util:sets:explode() {
#    for item in $(eval echo \${$1[@]}); do
#        echo ${item}
#    done | sort
#}
#
#function :util:sets:set_union() {
#    sort -um <( explode $1) <(explode $2)
#}
#
#function :util:sets:set_intersect() {
#    comm -12 <(explode $1) <(explode $2)
#}
#
#function :util:sets:set_complement() {
#    comm -23 <(explode $1) <(explode $2)
#}
#
#function :util:sets:set_symdiff() {
#    sd=( $(comm -3 <(explode $1) <(explode $2)) )
#    explode sd
#}
#. }=-

#. ANSI2HTML -={
function :util:ansi2html() {
    ${SITE_LIBEXEC_CORE}/ansi2html
}
#. }=-
