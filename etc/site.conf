# vim: tw=0:ts=4:sw=4:et:ft=bash

if [ -f ${HOME}/.siterc ]; then
    source ${HOME}/.siterc
fi
: ${PROFILE?}
: ${SITE_USERNAME:=$(whoami)}

HAS_TTY=1
[ -t 1 ] || HAS_TTY=0

unset CDPATH

export SITE=${HOME}/.site
export SITE_ETC=${SITE}/etc/${PROFILE}
export SITE_ETC_CORE=${SITE}/etc/core
export SITE_LIB=${SITE}/lib/${PROFILE}
export SITE_LIB_CORE=${SITE}/lib/core
export SITE_LIB_EXTERN=${SITE}/extern
export SITE_LIBEXEC=${SITE}/libexec/${PROFILE}
export SITE_LIBEXEC_CORE=${SITE}/libexec/core
export SITE_SCM=$(dirname $(dirname $(readlink ~/bin/site)))
export SITE_UNITDATA=${SITE}/share/unittest.csv

export SHUNIT2=${SITE_LIB_EXTERN}/shunit2
export SHFLAGS=${SITE_LIB_EXTERN}/shflags

export PATH=${PATH}:${SITE_LIBEXEC}:${SITE_LIBEXEC_CORE}

export NOW=$(date --utc +%s)

source ${SITE_ETC_CORE}/site.conf
[ ${#CORE_MODULES[@]} -ge 1 ] || : ${CORE_MODULES?}

declare -A USER_MODULES
if [ -d ${SITE_ETC} ]; then
    unset USER_MODULES
    source ${SITE_ETC}/site.conf
    [ ${#USER_MODULES[@]} -gt 0 ] || : ${USER_MODULES?}
    : ${USER_TLD?}
    : ${USER_TLD_MGMT?}
    : ${USER_UDN?}
    : ${USER_GDN?}
    : ${USER_NDN?}
fi

test ! -f ${SHFLAGS} || source ${SHFLAGS}
declare SUBNET_CONF=${SITE_ETC}/subnets.conf
declare SUBNET_FIELDS="name|alloc|comment|dc|gw|dnsz|env|legacy|svcmod|seczone|subnet|vlan"

BASENAME=$(basename $0)
SITE_CACHE=/var/tmp/${BASENAME}
mkdir -p ${SITE_CACHE}

#. Output -={
#declare -i ncolors=$(tput colors)
#if [ ${ncolors:=-2} -ge 8 ]; then
function ::cpf:theme() {
    local e=1

    local fmt
    if [ $# -ge 2 ]; then
        local op=${1:0:1}
        local th=${1:1:${#1}}
        fmt="%s"
        if [ $# -gt 2 ]; then
            local fmt="${2}"
            shift 2
            e=0
        else
            shift 1
            e=0
        fi
    fi

    if [ $e -eq 0 ]; then
        case ${op} in
            !)
                case ${th} in
                    module) ::cpf:module $@;;
                    function)
                        IFS=: read -r module fn <<<"$@"
                        ::cpf:function ${module} ${fn}
                    ;;
                    *) core:raise EXCEPTION_BAD_FN_CALL;;
                esac
            ;;
            @)
                case ${th} in
                    err|crit)            fmt="%{r:${fmt}}";;
                    warn)                fmt="%{y:${fmt}}";;
                    info)                fmt="%{wh:${fmt}}";;
                    pass)                fmt="%{g:${fmt}}";;
                    note)                fmt="%{m:${fmt}}";;
                    link)                fmt="%{b:${fmt}}";;
                    loc)                 fmt="%{c:${fmt}}";;
                    netgroup)            fmt="%{c:+${fmt}}";;
                    netgroup_empty)      fmt="%{+bo}%{bl:+${fmt}}%{-bo}";;
                    netgroup_missing)    fmt="%{+bo}%{r:+${fmt}}%{-bo}";;
                    netgroup_direct)     fmt="%{+bo}%{c:+${fmt}}%{-bo}";;
                    netgroup_indirect)   fmt="%{c:+${fmt}}";;
                    filer)               fmt="%{m:@${fmt}}";;
                    timestamp)           fmt="%{g:${fmt}}";;
                    comment)             fmt="%{bl:${fmt}}";;
                    query)               fmt="%{m:${fmt}}";;
                    profile)             fmt="%{y:${fmt}}";;
                    hash)                fmt="%{b:${fmt}}";;
                    fqdn)                fmt="%{y:${fmt}}";;
                    host)                fmt="%{y:@${fmt}}";;
                    host_bad)            fmt="%{r:@${fmt}}";;
                    ip)                  fmt="%{b:#${fmt}}";;
                    user)                fmt="%{m:${fmt}}";;
                    group)               fmt="%{m:%%${fmt}}";;
                    int)                 fmt="%{g:${fmt}}";;
                    fn)                  fmt="%{c:${fmt}}";;
                    mod)                 fmt="%{y:${fmt}}";;
                    path)                fmt="%{g:${fmt}}";;
                    bad_path)            fmt="%{r:${fmt}}";;
                    user)                fmt="%{y:${fmt}}";;
                    key)                 fmt="%{y:${fmt}}";;
                    val)                 fmt="%{g:${fmt}}";;
                    *)                   core:raise EXCEPTION_BAD_FN_CALL;;
                esac
                cpf "${fmt}" "$@"
            ;;
            *) core:raise EXCEPTION_BAD_FN_CALL;;
        esac
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi
}
declare -A COLORS=(
    [N]="$(tput sgr0)"      [R]="$(tput rev)"

    [+ul]="$(tput smul)"    [-ul]="$(tput rmul)"
    [+st]="$(tput smso)"    [-st]="$(tput rmso)"
    [+bo]="$(tput bold)"    [-bo]="$(tput sgr0)"

    [bl]="$(tput setaf 0)"  [wh]="$(tput setaf 7)"
    [r]="$(tput setaf 1)"   [g]="$(tput setaf 2)"
    [y]="$(tput setaf 3)"   [b]="$(tput setaf 4)"
    [m]="$(tput setaf 5)"   [c]="$(tput setaf 6)"
)
function cpf() {
    #. cpf "%{ul:%s}, %{r}%{bo:%s}, and %{st:%s}%{no}\n" underlined bold standard
    LC_ALL=C

    if [ $# -gt 0 ]; then
        local str="$1"
        while read var; do
            if [[ ${var} =~ ^%\{([^:]+):([^}]*)}$ ]]; then
                op=${BASH_REMATCH[1]}
                token=${BASH_REMATCH[2]}

                #. Convert @theme to colorchar
                if [ "${op:0:1}" == '@' ] || [ "${op:0:1}" == '!' ]; then
                    if [ ${HAS_TTY} -eq 1 ]; then
                        str=${str//${var}/$(::cpf:theme ${op} "${token}")}
                    else
                        str=${str//${var}/${token}}
                    fi
                fi

                case ${op} in
                    rv|bl|wh|r|g|y|b|m|c)
                        if [ ${HAS_TTY} -eq 1 ]; then
                            str=${str//${var}/${COLORS[${op}]}${token}${COLORS[N]}}
                        else
                            str=${str//${var}/${token}}
                        fi
                    ;;
                    ul|st|bo)
                        if [ ${HAS_TTY} -eq 1 ]; then
                            str=${str//${var}/${COLORS[+${op}]}${token}${COLORS[-${op}]}}
                        else
                            str=${str//${var}/${token}}
                        fi
                    ;;
                esac
            elif [[ ${var} =~ ^%\{([^:]+)}$ ]]; then
                if [ ${HAS_TTY} -eq 1 ]; then
                    op=${BASH_REMATCH[1]}
                    str=${str//${var}/${COLORS[${op}]}}
                else
                    str=${str//${var}/}
                fi
            else
                #core:raise EXCEPTION_BAD_FN_CALL
                echo ouch $var
                exit 4
            fi
        done < <(echo ${str}|grep -oE '%{[^}]+}')

        shift
        echo ${str}|grep -qE '%{'
        if [ $? -eq 0 ]; then
            echo "CPF Failure: ${str}"
            exit
        fi
        printf "${str}" "$@"
    else
        echo
    fi
}
function c() { core:raise EXCEPTION_DEPRECATED; }

function theme() {
    if [ $# -gt 0 ]; then
        local dvc=/dev/stdout
        local item=$1; shift
        local fmt
        case ${item} in
            HAS_PASSED)          fmt="%{g}PASS";;
            HAS_WARNED)          fmt="%{y}WARN";;
            HAS_FAILED)          fmt="%{r}FAIL";;

            FALSE)               fmt="%{r}FALSE";;
            TRUE)                fmt="%{g}TRUE";;

            INFO)                fmt="%{wh}INFO"; dvc=/dev/stderr;;
            NOTE)                fmt="%{wh}NOTE"; dvc=/dev/stderr;;
            WARN)                fmt="%{y}WARN";  dvc=/dev/stderr;;
            DEPR)                fmt="%{y}WARN";  dvc=/dev/stderr;;
            ERR)                 fmt="%{r}ERROR"; dvc=/dev/stderr;;
            ERR_USAGE)           fmt="%{r}USAGE ERROR"; dvc=/dev/stderr;;

            TODO)                fmt="%{y}TODO"; dvc=/dev/stderr;;
            FIXME)               fmt="%{r}FIXME"; dvc=/dev/stderr;;

            ERR_INTERNAL)        fmt="%{r}INTERNAL ERROR"; dvc=/dev/stderr;;
            ALERT)               fmt="%{r}ALERT"; dvc=/dev/stderr;;

            *) core:raise EXCEPTION_BAD_FN_CALL
        esac

        case ${item} in
            [A-Z]*)
                [ $# -eq 0 ] || fmt+=" %{+bo}[%s]%{-bo}"
                fmt+="%{N}\n"
            ;;
        esac

        if [ ${HAS_TTY} -eq 1 ]; then
            cpf "${fmt}" "$@" >${dvc}
        else
            cpf "${fmt}" "$@"
        fi
    else
        if [ ${HAS_TTY} -eq 1 ]; then
            echo >${dvc}
        else
            echo
        fi
    fi
}

function ::cpf:module_is_modified() {
    local -i e=9
    local profile=$1
    local module=$2
    cd ${SITE_SCM}
    if [ -e "${SITE}/lib/${profile}/${module}" ]; then
        local path=$(readlink "${SITE}/lib/${profile}/${module}")
        local amended=$(git status --porcelain "${path}"|wc -l)
        [ ${PIPESTATUS[0]} -ne 0 ] || e=${amended}
    fi
    cd ${OLDPWD}
    return $e
}

function ::cpf:module_has_alerts() {
    local -i e=${CODE_FAILURE}

    local profile=$1
    local module=$2
    if [ -e "${SITE}/lib/${profile}/${module}" ]; then
        grep -qE "^function ${module}:[a-z0-9]+:alert()" "${SITE}/lib/${profile}/${module}"
        [ $? -ne 0 ] || e=${CODE_SUCCESS}
    fi

    return $e
}

function ::cpf:function_has_alerts() {
    local -i e=${CODE_FAILURE}

    local profile=$1
    local module=$2
    local fn=$3
    if [ -e "${SITE}/lib/${profile}/${module}" ]; then
        grep -qE "^function ${module}:${fn}:alert()" "${SITE}/lib/${profile}/${module}"
        [ $? -ne 0 ] || e=${CODE_SUCCESS}
    fi

    return $e
}

function ::cpf:module() {
    local -r module=$1

    local -i enabled=1
    local -i alerts=0
    local -i amended=0
    local fmt
    if [ -e ${SITE_LIB_CORE}/${module} ]; then
        if ::cpf:module_has_alerts core ${module}; then
            alerts=1
            fmt="%{y}"
        else
            fmt="%{c}"
            ::cpf:module_is_modified core ${module}
            amended=$?
        fi
        enabled=${CORE_MODULES[${module}]}
    elif [ -e ${SITE_LIB}/${module} ]; then
        if ::cpf:module_has_alerts ${PROFILE} ${module}; then
            alerts=1
            fmt="%{y}"
        else
            fmt="%{b}"
            ::cpf:module_is_modified ${PROFILE} ${module}
            amended=$?
        fi
        enabled=${USER_MODULES[${module}]}
    fi

    [ ${amended} -eq 0 ] || fmt+="%{ul}"
    [ ${enabled} -eq 0 ] || fmt+="%{bo}"

    cpf "${fmt}%s%{N}" ${module}
}
function ::cpf:function() {
    local -r module=$1
    local -r fn=$2

    local -i enabled=1
    local -i alerts=0
    local -i amended=0
    local fmt
    if [ -e ${SITE_LIB_CORE}/${module} ]; then
        if ::cpf:function_has_alerts core ${module} ${fn}; then
            alerts=1
            fmt="%{y}"
        else
            fmt="%{c}"
            ::cpf:module_is_modified core ${module}
            amended=$?
        fi
        enabled=${CORE_MODULES[${module}]}
    elif [ -e ${SITE_LIB}/${module} ]; then
        if ::cpf:function_has_alerts ${PROFILE} ${module} ${fn}; then
            alerts=1
            fmt="%{y}"
        else
            fmt="%{b}"
            ::cpf:module_is_modified ${PROFILE} ${module}
            amended=$?
        fi
        enabled=${USER_MODULES[${module}]}
    fi

    [ ${amended} -eq 0 ] || fmt+="%{ul}"
    [ ${enabled} -eq 0 ] || fmt+="%{bo}"

    cpf "${fmt}%s %{b:%s}%{N}" ${module} ${fn}
}
#. }=-
#. Exceptions -={
EXCEPTION=63
EXCEPTION_BAD_FN_CALL=64
EXCEPTION_MISSING_EXEC=65
EXCEPTION_BAD_MODULE=66
EXCEPTION_DEPRECATED=67
EXCEPTION_MISSING_PERL_MOD=68
EXCEPTION_MISSING_PYTHON_MOD=69
EXCEPTION_UNHANDLED=127
declare -A RAISE=(
    [${EXCEPTION_BAD_FN_CALL}]="Bad function call internally"
    [${EXCEPTION_MISSING_EXEC}]="Required executable not found"
    [${EXCEPTION_BAD_MODULE}]="Bad module"
    [${EXCEPTION_DEPRECATED}]="Deprecated function call"
    [${EXCEPTION_MISSING_PERL_MOD}]="Required perl module missing"
    [${EXCEPTION_MISSING_PYTHON_MOD}]="Required perl module missing"
)
function core:raise() {
    sleep 0.2
    local -i e=$1

    cpf "%{r}Exception[%{st:%s}]: %s ($*) %{N}\n" ${e} "${RAISE[$e]-[UNKNOWN EXCEPTION:$e]}" 1>&2

    if [ ${#module} -gt 0 ]; then
        if [ ${#fn} -gt 0 ]; then
            cpf "Function %{c:${module}:${fn}()}" 1>&2
        else
            cpf "Module %{c:${module}}" 1>&2
        fi
    else
        cpf "File %{g:$0}" 1>&2
    fi

    cpf " %{r:failed with exception} %{g:$e}; %{c:traceback}:\n" 1>&2
    local i=0
    local -i frames=${#BASH_LINENO[@]}
    #. ((frames-2)): skips main, the last one in arrays
    for ((i=frames-2; i>=0; i--)); do
        cpf "  File %{g:${BASH_SOURCE[i+1]}}, line %{g:${BASH_LINENO[i]}}, in %{r:${FUNCNAME[i+1]}()}\n" 1>&2
        # Grab the source code of the line
        local code=$(sed -n "${BASH_LINENO[i]}{s/^ *//;p}" "${BASH_SOURCE[i+1]}")
        cpf "    %{wh:>>>} %{c}${code}%{N}\n" 1>&2
    done

    exit $e
}
#. }=-
#. Core -={
declare -A SITE_IMPORTED
function core:softimport() {
    local -i e=9
    if [ $# -eq 1 ]; then
        local module=$1
        if [ -z "${SITE_IMPORTED[${module}]}" ]; then
            e=2 #. No such module
            if [ ${USER_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_LIB}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_LIB}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_LIB_CORE}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_LIB_CORE}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 0 -o ${USER_MODULES[${module}]-9} -eq 0 ]; then
                e=${CODE_FAILURE} #. Disabled
            fi
            SITE_IMPORTED[${module}]=$e
        else
            e=${SITE_IMPORTED[${module}]}
        fi
    fi

    return $e
}

function core:import() {
    core:softimport $@
    local -i e=$?
    [ $e -eq 0 ] || core:raise EXCEPTION_BAD_MODULE

    return $e
}

function core:requires() {
    #. Usage examples:
    #.
    #.     core:requires awk
    #.     core:requires perl LWP::Protocol::https
    local -i e=${CODE_SUCCESS}

    case $#:${1} in
        1:*)
            if echo $1|grep -q '/'; then
                if [ ! -e $1 ]; then
                    e=2
                fi
            else
                which $1 > /dev/null 2>&1
                if [ $? -ne 0 ]; then
                    e=${CODE_FAILURE}
                fi
            fi

            if [ $e -ne 0 ]; then
                local caller="${FUNCNAME[1]}"
                local caller_is_mod=$(( ${USER_MODULES[${caller/:*/}]-0} + ${CORE_MODULES[${caller/:*/}]-0} ))
                if [ ${caller_is_mod} -ne 0 ]; then
                    core:raise EXCEPTION_MISSING_EXEC $1
                fi
            fi
        ;;
        2:perl)
            if ! perl -M${2} -e ';' 2>/dev/null; then
                core:raise EXCEPTION_MISSING_PERL_MOD $2
            fi
        ;;
        2:python)
            if ! python -c "import ${2}" 2>/dev/null; then
                core:raise EXCEPTION_MISSING_PYTHON_MOD $2
            fi
        ;;
        *) core:raise EXCEPTION_BAD_FN_CALL $*;;
    esac

    test $e -eq 0 && return $e || exit $e
}

#. Error Codes -={
true
TRUE=$?
CODE_SUCCESS=${TRUE?}

false
FALSE=$?
CODE_FAILURE=${FALSE?}

CODE_ERROR=1               #. 1..63   Errors
CODE_E01=1
CODE_E02=2
CODE_E03=3
CODE_E04=4
CODE_E05=5
CODE_E06=6
CODE_E07=7
CODE_E08=8
CODE_E09=9

CODE_USER_MAX=63           #. 64..127 Internal
CODE_DISABLED=64
CODE_USAGE_SHORT=90
CODE_USAGE_MODS=91
CODE_USAGE_MOD=92
CODE_USAGE_FN_GUESS=93
CODE_USAGE_FN_SHORT=94
CODE_USAGE_FN_LONG=95

CODE_DEFAULT=${CODE_USAGE_FN_LONG?}
#. }=-

function ::core:eval:dereference() {
    #. NOTE: you myst eval the output of this function!
    #. take $1, and make it equal to ${$1}
    #.
    #. If the variable starts with _, remove it in the new variable
    #. Input: _my_var=something; something=( A B C )
    #. Output: my_var=( A B C )
    if [ ! -t 1 ]; then
        echo "unset ${1} && eval \$(declare -p ${!1}|sed -e 's/declare -\([a-qs-zA-Z]*\)r*\([a-qs-zA-Z]*\) ${!1}=\(.*\)/declare -\1\2 ${1}=\3/')";
    else
        core:raise EXCEPTION_BAD_FN_CALL \
            "This function must be called in a subshell, and evaled afterwards!"
    fi
}

function ::core:execute:internal() {
    local module=$1
    local fn=$2
    shift 2
    #set -x
    :${module}:${fn} ${*}
    #set +x
    return $?
}

function ::core:execute:private() {
    local module=$1
    local fn=$2
    shift 2
    #set -x
    ::${module}:${fn} ${*}
    #set +x
    return $?
}

function :core:execute() {
    local -i e=${CODE_USAGE_MODS}

    if [ $# -ge 1 ]; then
        e=${CODE_USAGE_MOD}
        if [ $# -ge 2 ]; then
            declare -g module=$1
            declare -g fn=$2
            shift 2

            if [ "$(type -t ${module}:${fn})" == "function" ]; then
                if [ "$(type -t ${module}:${fn}:shflags)" == "function" ]; then
                    #. shflags function defined, so let's use it...
                    while read f_type f_long f_default f_desc f_short; do
                        DEFINE_${f_type} "${f_long}" "${f_default}" "${f_desc}" "${f_short}"
                    done < <( ${module}:${fn}:shflags )
                    FLAGS "$@"
                    e=$?
                    if [ $e -eq 0 ]; then
                        eval set -- "${FLAGS_ARGV}"
                        ${module}:${fn} ${*}
                        e=$?
                    fi
                else
                    #. No shflags, so let's just run with it...
                    ${module}:${fn} ${*}
                    e=$?
                fi

                if [ ${HAS_TTY} -eq 1 -a "$(type -t ${module}:${fn}:alert)" == "function" ]; then
                    cpf "%{r:ALERTS}%{bl:@}%{g:${PROFILE}} %{!function:${module} ${fn}}:\n"
                    while read line; do
                        set ${line}
                        local alert=$1
                        shift
                        theme ${alert} "$*"
                    done < <(${module}:${fn}:alert)
                    echo
                fi
            else
                theme ERR_INTERNAL "Function ${module}:${fn} not defined!"
            fi
        fi
    fi

    if [ ${HAS_TTY} -eq 1 -a $e -eq 0 -a ${SECONDS} -ge 30 ]; then
        theme INFO "Execution time was ${SECONDS} seconds"
    fi

    return $e
}

function :core:usage() {
    local module=$1
    local fn=$2
    local mode=${3---short}
    [ $# -eq 2 ] && mode=${3---long}

    if [ ${#FUNCNAME[@]} -lt 4 ]; then
        cpf "%{wh:SysConfig Site} - %{y:System-Administration Suite}\n"
        cpf "Using %{@path:%s} %{b:%s}" "${BASH}" "${BASH_VERSION}"
        if [ ${#SITE_SHELL} -eq 0 ]; then
            cpf " %{@comment:(export SITE_SHELL to override)}"
        else
            cpf " %{r:(SITE_SHELL override active)}"
        fi
        printf "\n\n"
    fi

    if [ $# -eq 0 ]; then
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}}\n"
        cpf "    %{bl:${BASENAME}} "
        for profile in USER_MODULES CORE_MODULES; do
            eval $(::core:eval:dereference profile) #. Will create ${profile}
            for module in ${!profile[@]}; do
                cpf "%{!module:${module}}%{wh:|}"
            done
        done
        echo help
    elif [ $# -eq 1 ]; then
        core:import ${module}
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}} %{!module:${module}}\n"
        fns=( $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}') )
        for fn in ${fns[@]}; do
            cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} %{c:%s}\n" "$(${module}:${fn}:usage)"
        done

        if [ ${#FUNCNAME[@]} -lt 4 ]; then
            echo
            cpf "%{!module:${module}} %{g:changelog}\n"
            local modfile=${SITE_SCM}/lib/${PROFILE}/${module}
        [ -f ${modfile} ] || modfile=${SITE_SCM}/lib/core/${module}
            cd ${SITE_SCM}
            git --no-pager\
                log --follow --all --format=format:'    |___%C(bold blue)%h%C(reset) %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)â€” %an%C(reset)%C(bold yellow)%d%C(reset)'\
                --abbrev-commit --date=relative -- "${modfile}"
            cd ${OLDPWD}
            echo
        fi
        echo
    elif [ $# -ge 2 ]; then
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}} %{!function:${module}:${fn}}\n"
        cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} "

        case ${mode} in
            --short)
                local usage_s=${module}:${fn}:usage
                cpf "%{c:%s}\n" "$(${usage_s})"
                ;;
            --long)
                local usage_s=${module}:${fn}:usage
                cpf "%{c:%s}\n" "$(${usage_s})"
                echo

                local usage_l=${module}:${fn}:help
                local -i i=0
                if [ "$(type -t $usage_l 2>/dev/null)" == "function" ]; then
                    local indent=""
                    while read line; do
                        cpf "%{c:%s}\n" "${indent}${line}"
                        [ $i -eq 0 ] && indent+="    "
                        ((i++))
                    done <<< "`${usage_l}`"
                elif [ "$(type -t $usage_s 2>/dev/null)" == "function" ]; then
                    cpf "%{c:%s}\n" "$(${usage_s})"
                else
                    cpf
                fi
            ;;
        esac
    fi
}

function :core:complete() {
    local module=$1
    local fn=$2
    for afn in $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}'); do
        local AC_${module}_${afn}
    done
    local -a completed=( $(eval echo \${!AC_${module}_${fn}*}) )
    if echo ${completed[@]} | grep -qE "\<AC_${module}_${fn}\>"; then
        echo ${fn}
    else
        echo ${completed[@]//AC_${module}_/}
    fi
}

function core:wrapper() {
    local -i e=${CODE_USAGE_MODS}

    declare -g module=${1:--}
    declare -g fn=${2:--}

    core:softimport ${module}
    case $?/${module}/${fn} in
        0/-/-)      shift 0;                                               e=${CODE_USAGE_MODS} ;;
        0/*/-)      shift 1;  :core:execute          ${module}           ; e=$? ;;
        0/*/::*)    shift 2; ::core:execute:private  ${module} ${fn:2} $*; e=$? ;;
        0/*/:*)     shift 2; ::core:execute:internal ${module} ${fn:1} $*; e=$? ;;
        0/*/*)
            shift 2
            local -a completed=( $(:core:complete ${module} ${fn}) )
            if [ ${#completed[@]} -eq 1 ]; then
                fn=${completed}
                :core:execute ${module} ${completed} $*
                e=$?
            elif [ $# -ge 2 -a ${#completed[@]} -gt 1 ]; then
                theme ERR_USAGE "Did you mean one of the following:"
                for acfn in ${completed[@]}; do
                    echo "    ${BASENAME} ${module} ${acfn}"
                done
                e=${CODE_USAGE_FN_GUESS}
            else
                theme ERR_USAGE "${fn} not defined"
                e=${CODE_USAGE_MOD}
            fi
        ;;
        2/-/-) e=${CODE_USAGE_MODS};;
        2/*/*)
            theme ERR_USAGE "Module ${module} has not been defined"
            e=${CODE_FAILURE}
        ;;
        1/*/*)
            theme ERR_USAGE "Module ${module} has been administratively disabled"
            e=${CODE_DISABLED}
        ;;
        */*/*)
            e=${CODE_FAILURE}
            core:raise EXCEPTION_BAD_FN_CALL "Check call/caller to/of \`core:softimport $*'"
        ;;
    esac

    case $e in
        ${CODE_USAGE_MODS})    :core:usage ;;
        ${CODE_USAGE_SHORT})   :core:usage ${module} ;;
        ${CODE_USAGE_MOD})     :core:usage ${module} ;;
        ${CODE_USAGE_FN_LONG}) :core:usage ${module} ${fn} ;;
        0) : noop;;
    esac

    return $e
}
#. }=-
